# git

```
* 633e6fd (HEAD -> b5) Добавил библиотеку
| * a116155 (b3) Добавил сортировку
| | * 2c627a7 (b4) Рефакторинг
| | | *   d9ea197 (b2) Объединил исправления
| | | |\  
| | |_|/  
| |/| |   
| * | | 2f27fa8 Убрал опечатку
|/ / /  
| | | * cc7239e (master) Объединил код
| | |/| 
| |/|/  
| | * cd55e2e Переписал функцию
| * | 756a56c Очистил код
| | | * 6476854 (b1) Объединил наработки
| |_|/| 
|/| |/  
| |/|   
| * | ec0bcd7 Добавил тесты
* | | 81d030d Добавил документацию
| |/  
|/|   
* | a93c3d2 Исправил ошибку
|/  
* 0d19eb5 Добавил файлы
```

Git - это глобальная история изменений файлов в одной папке.

Чтобы лучше понять принцип работы Git и его внутреннее устройство, лучше всего это сделать через низкоуровневые операции с ним, поэтому создадим хранилище Git в новой пустой папке следующей командой

    git init

Для хранения содержимого любых файлов Git использует объект **blob**. Создадим blob с текстом внутри

    echo 'люблю яблоки' | git hash-object -w --stdin

Все объекты хранятся во внутренней папке Git `.git/objects`. Наш blob появится в виде файла `.git/objects/f0/2e02a059f190d3e68d42f8438fa3f094eda1b5`. Имя папки и файла вместе являются значением чексуммы SHA1 от этого файла. То есть место расположение объекта напрямую связано с его содержимым. Такие способы хранения называются "контентно-адресуемыми".

Но как же Git знает об именах файлов и в каких они папках? Для этого используется объект **tree**, который хранит один уровень файлов и папок в виде чексумм blob и tree.

```
tree 7c40534e0fe0bc3e4507ff5c39f3d33c513b6dbb
├── tree myfolder1 83781f91be8e9dcde382a873f2ea4b25240a32bd
│   └── blob sourcefile.c eae0203f03b1864f79f8a4c9e11cc85b503317bb
├── tree myfolder2 29f2577dbbf09f655fd0941927c37f9c04ea4f1e
│   ├── blob program.py b03858d332ea0ac2fe445b257d24454458e54b8d
│   └── blob script.sh e96f119abc426f9b89bfab4774c17e977df6a500
├── blob notes.txt b4e9425c74ae5608b2e25e85f9d8ee9da6565bda
└── blob users.csv 2a1b358981b813acb2b22abd50fb074da249f255
```

Здесь представлен пример. Один tree самый верхний, который содержит чексуммы и имена других blob и tree, которые в свою очередь содержат чексуммы своих blob и tree. Если какой то файл изменится, то изменится его чексумма, а значит будет создан новый blob, а значит и tree с его чексуммой и других tree, содержащих чексумму этого tree. Таким образом Git хранит одну версию каких-нибудь файлов и папок.

Создадим tree с созданным ранее blob

    echo -e '100644 blob f02e02a059f190d3e68d42f8438fa3f094eda1b5\tnote.txt' | git mktree

Просмотрим созданный tree

    git ls-tree -r -t 1f0827b55a3b1256fa92256e94c1e3be8f08dfc7

Для придания смысла версиям данных и выстраивания их в историю изменений используется объект **commit**. В него записывается чексумма самого верхнего tree, примечание и автор версии.

Создадим commit с нашим tree

    echo 'создал заметку' | git commit-tree 1f0827b55a3b1256fa92256e94c1e3be8f08dfc7

*Здесь Git попросит вас представится, так как ваши данные указываются в создаваемых commit.*

Несколько commit могут выстраиваться в историю. Для этого следующий commit содержит чексумму предыдущего.

Создадим следующую версию данных в blob, а за ним tree и commit с чексуммой предыдущего

    echo 'люблю апельсины' | git hash-object -w --stdin
    echo -e '100644 blob 3afe8b4acba7ef2a3753c7726a3fad921e3169f5\tfile1.txt' | git mktree
    echo 'поменял вкусы' | git commit-tree 4279b58515af6b00c0c74e963b69f86577fd6050 -p 1160171502ebab31a3cce78fa310afa5971dbc6c

Иногда нам нужно разделить историю изменений на две разные версии, а иногда наоборот объединить две версии в одну. При разделении получается, что в двух commit чексумма одного общего commit, а при слиянии один commit содержит чексуммы двух других.

Просмотрим все созданные нами объекты

    git cat-file --batch --batch-all-objects

Во большинстве обычных команд при работе с Git используется отдельный файл **index** (который ещё может называться stage или cache), который используется, как временное хранилище для формирования списка файлов и папок, которые будут занесены в новый главный tree со всеми остальными blob и tree. Эта промежуточная информация нужна, чтобы понять какие новые изменения были сделаны в рабочей папке и какие из них мы хотим добавить в новый tree для следующего commit.

Пример добавления записи в index

    git update-index --add --cacheinfo 100644 3afe8b4acba7ef2a3753c7726a3fad921e3169f5 folder1/folder2/file1.txt

Создать tree из текущего index

    git write-tree

Последнее, что необходимо понять - это **ссылки**, которые заменяют собой чексуммы при выполнении команд, ведь обращаться с понятными названиями проще, чем с набором букв и цифр. Физически это обычные текстовые файлы с чексуммой внутри.

Создадим ссылку на наш последний commit

    echo ed5e74821d5e398855f5dece56cb08ce3f7ed2c7 > .git/refs/heads/master

Виды ссылок

- **branch** - последний commit в истории изменений (`refs/heads/`)
- **HEAD** - указывает на branch или commit, на котором по мнению Git мы сейчас находимся
- **tag** - просто удобная ссылка на любой объект (`refs/tags/`)
- tag в виде commit-подобного объекта для добавления подробностей (на этот tag в свою очередь создаётся ссылка из обычного tag)
- **remote** - branch в удалённом хранилище (`refs/remotes/<имя_хранилища>/`)

## Обычные команды

В процессе обычной работы всё намного проще и нет необходимости выполнять все эти ручные команды для каждого файла и папки. Нужно лишь понимание внутренней работы Git.

Допустим у нас есть папка с файлами, и нам нужно сохранить всё

    git add -A

Эта команда сначала добавляет в index разницу между `HEAD` и рабочей папкой. `HEAD` изначально указывает на ссылку master, которая пока даже не существует. Всё добавленные файлы и папки сохранятся в объектах blob и tree.

Далее создаём commit

    git commit -m 'описание изменений в файлах'

Команда проверит index, создаст главный tree и запишет его чексумму в новый commit. Также добавит чексумму предыдущего commit, если это не первый, и переместит ссылку HEAD на новый commit.

Иногда уместнее добавлять в новый commit только часть правок, чтобы разделить их по смыслу.

- `git add -i` - добавление изменений с помощью командного меню
- `git add -p` - разделное внесение изменений в пределах одного файла

Другие полезные команды

- `git log --graph --oneline --all` - просмотреть всю историю в компактном виде
- `git show a472be2` - показать новые изменения в конкретном commit
- `git diff 2b93ay5 6a94e` - показать разницу двух commit

## checkout

Мы можем возвращать прошлу версию данных из Git в текущую папку

    git checkout 9dd5bt4

Сброс достаёт данные из объектов, но не переключает HEAD

- `git reset eb21e` - загрузить из branch/commit/tree в index
- `git reset --hard eb21er3` - загрузить из branch/commit/tree в index и рабочую папку

Стоит заметить, что `checkout` и `reset` не трогают неизвестные для Git файлы (если они не упоминались ни в одном tree).

- `git clean` - удалить неизвестные для Git файлы в рабочей папке

Если нам не нравятся изменения, сделанные в каком-либо commit, то можно сделать обратный commit

    git revert eb21ew2

## branch

Управление ветками историй

- `git branch` - список всех branch
- `git branch test1` - назначить текущему commit новый branch
- `git branch -m test1 dev1` - переименование
- `git branch -f dev2 2b93af3` - перемещение
- `git switch dev1` - перейти на другой branch и commit
- `git switch -c dev2` - назначить текущему commit новый branch и направить на него HEAD
- `git checkout --orphan b2` - создать независимый branch

Если commit не связан цепочкой commit с каким-либо branch, то он считается недосягаемым и будет удалён при очистке репозитория (и все данные в нём).

- `git fsck --unreachable` - отобразить недосягаемые commit

## merge

*Make us Whole*

Объединение разных историй в одну. Фактически это объединение главного tree из разных branch/commit в один новый. Например, для включения наработок из отдельной ветки в основную.

Запустить слияние ветки dev1 с текущей

    git merge dev1

Если при слиянии обнаружатся разные версии одних и тех же файлов, тогда

- `git status` сообщит необходимые действия
- в самих файлах в рабочей папке будут вставлены правки из обеих версий для удобства
- конфликтующие файлы появятся в index (`git ls-files --stage`) с разными номерами

После ручного объединения различий потребуется снова добавить их в index и можно будет сделать commit.

Если вы производите слияние историй, не являющихся разделением одной, то это не связанные истории. По умолчанию в Git это запрещено во избежание недоразумений, но это можно всё равно сделать с опцией `--allow-unrelated-histories`.

## remote

Git имеет обмениваться ветками историй с другими Git. Так устроена совместная работа нескольких людей (даже десятков тысяч!) над одними и теми же файлами.

Для начала добавим удалённый репозиторий Git

    git remote add example git://example.org:2222/group1/project1.git

Теперь мы можем передать туда ветку истории, то есть branch

    git push branch1 example

Если кто-то также передал изменения, мы можем их получить

    git fetch

Другие команды

- `git clone git://example.org:2222/group1/project1.git` - скачать новый репозиторий и настроить remote
- `git remote -v` - подключенные репозитории
- `git pull` - выполнить `git fetch` и `git merge`

## stash

Если нужно что-то быстренько поковырять в Git, но мешаются файлы в рабочей папке, то необязательно их все переносить куда-то вручную. Можно, конечно, сделать commit, который потом удалить из истории, но есть способ проще.

Быстро сохранить текущие изменения в отдельный commit

    git stash -u

Просмотреть сохранения

    git stash list

Достать последнее сохранение

    git stash apply

## rebase

Перестроение истории. Название происходит из наиболее частого случая применения команды - перемещения истории, как более наглядная замена merge.

Допустим мы находимся на ветке dev1, которая была ответвлена давно и хотим её переместит на последний commit в ветке master, чтобы это выглядело, как одна история

    git rebase master

Переместить от 3b5ae7c до c5930e5 в начало 2a288e6

    git rebase --onto 2a288e6 3b5ae7c c5930e5

Было

```
* c5930e5 (dev) commit7
* cf107c2 commit6
* f1c1faf commit5
* 3b5ae7c (master) commit4
| * 7e12d20 (branch1) commit3
|/  
* 8f67736 commit2
* 2a288e6 (HEAD) commit1
```

Стало

```
* 7bb65d9 (HEAD) commit7
* 95500fc commit6
* ebdac0d commit5
| * c5930e5 (dev) commit7
| * cf107c2 commit6
| * f1c1faf commit5
| * 3b5ae7c (master) commit4
| | * 7e12d20 (branch1) commit3
| |/  
| * 8f67736 commit2
|/  
* 2a288e6 commit1
```

С помощью интерактивного режима можно **полностью переделать историю commit**

    git rebase -i 9e6a86a~

Выведется история от указанного commit до текущего. Слева будет указано применяемое действие, а снизу справка. Например, для объединения нескольких commit меняем `pick` у идущих после него на `squash`. Чтобы наоборот разбить commit на несколько, пишем `edit`. После установки действий сохраняем файл.

На каждый `edit` происходит checkout. Вносим нужные исправления и потом

    git add изменённый_файл1 изменённая_папка2
    git rebase --continue

Либо заносим в index часть изменений (например, через интерактивный add) и делаем

    git commit -m 'часть правок'

Если изменение будет пересекаться с последующим commit, то rebase остановится и предложит сделать merge. Вручную сливаем конфликт и делаем

    git add файл_с_объединением1
    git rebase --continue

Важно заметить, что rebase не меняет текущих данных, а создаёт новые commit, что позволяет всегда отменить процесс rebase, отбросив их

    git rebase --abort

## config

- `git config -l` - текущие настройки
- `git config user.name John Smith` - имя автора commit
- `git config user.email s.john@mail.net` - почта автора commit (может быть пустой строкой)
- `git config core.editor vim` - редактор примечаний при создании commit

## Прочие команды

- `git cherry-pick fc92d5s` - создать новый commit с изменениями, которые произошли в указанном commit по сравнению с его предшественником (можно использовать для перестроения цепочки commit)
- `git ls-tree -r HEAD` - список файлов в tree или commit
- `git fsck` - найти blob/tree, не связанные ни с одним commit
- `git checkout 47c98a3 .` - выгрузить tree в указанную папку


Удаление blob и tree, не связанных ни с одним commit

    git reflog expire --expire=now --all
    git repack -ad
    git prune

## git-filter-repo

Удаление данных из истории

https://docs.github.com/ru/authentication/keeping-your-account-and-data-secure/removing-sensitive-data-from-a-repository#using-git-filter-repo

    pip install --user git-filter-repo
    git-filter-repo --invert-paths --path 'passwords.txt'

