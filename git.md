# git

```
* 633e6fd (HEAD -> b5) Добавил библиотеку
| * a116155 (b3) Добавил сортировку
| | * 2c627a7 (b4) Рефакторинг
| | | *   d9ea197 (b2) Объединил исправления
| | | |\  
| | |_|/  
| |/| |   
| * | | 2f27fa8 Убрал опечатку
|/ / /  
| | | * cc7239e (master) Объединил код
| | |/| 
| |/|/  
| | * cd55e2e Переписал функцию
| * | 756a56c Очистил код
| | | * 6476854 (b1) Объединил наработки
| |_|/| 
|/| |/  
| |/|   
| * | ec0bcd7 Добавил тесты
* | | 81d030d Добавил документацию
| |/  
|/|   
* | a93c3d2 Исправил ошибку
|/  
* 0d19eb5 Добавил файлы
```

Git используют для сохранения изменений в файлах, эдакая глобальная история файлов в папке.

Git ведёт историю файлов в виде хранилища объектов **blob**, **tree** и **commit**, которые лежат во внутренней папке objects.

Проще всего понять Git можно на низкоуровневых действиях с ним, поэтому создаём для начала пустой Git в новой пустой папке

    git init

Запишем в Git объект **blob** с текстом

    echo 'просто текст' | git hash-object -w --stdin

Объект сохранится в файле `.git/objects/73/977f7f3c8281c5811d17f747535e65f78e899a`. Набор чисел и букв является чексуммой этого объекта. Таким образом все объекты в Git имеют адрес в соответствии со своим содержимым.

Объект blob используется для хранения содержимого наших файлов, но не содержит ни имени файла, ни его пути, ни прав. Для этого используется объект **tree**.

Выглядит это так

```
tree 7c40534e0fe0bc3e4507ff5c39f3d33c513b6dbb
├── tree myfolder1 83781f91be8e9dcde382a873f2ea4b25240a32bd
│   └── blob sourcefile.c eae0203f03b1864f79f8a4c9e11cc85b503317bb
├── tree myfolder2 29f2577dbbf09f655fd0941927c37f9c04ea4f1e
│   ├── blob program.py b03858d332ea0ac2fe445b257d24454458e54b8d
│   └── blob script.sh e96f119abc426f9b89bfab4774c17e977df6a500
├── blob notes.txt b4e9425c74ae5608b2e25e85f9d8ee9da6565bda
└── blob users.csv 2a1b358981b813acb2b22abd50fb074da249f255
```

Создадим объект tree с нашим созданным ранее blob

    echo -e '100644 blob 73977f7f3c8281c5811d17f747535e65f78e899a\tfile1.txt' | git mktree

Самый верхний tree является важным. Он используется в объекте **commit**, который хранит его чексумму, чьё-то имя и почту и комментарий и таким образом по смыслу является фактом занесения в Git некоторой версии отслеживаемых через Git файлов.

Пример создания commit

    echo 'добавил файл' | git commit-tree bf6981d12a7bf909b6b717bf944957033a1a258f

В объекте commit может быть чексумма других commit. По смыслу это означает, что файлы в нём являются следующими по версии.

Создадим следующую версию файла

    echo 'новый текст' | git hash-object -w --stdin
    echo -e '100644 blob 043ede82ab9bf5e5c6cfcdd5735630afa7f05281\tfile1.txt' | git mktree
    echo 'изменил файл' | git commit-tree 14cd11c64a1b90a3b4f3cf1e40bf23778f7a42a8 -p ab1e01f0ac5e75b91d7ffe072b235be195a675a0

Бывает так, что на один и тот же commit ссылается множество других - это называется **ветвлением**, то есть мы работали с какими-то файлами и решили делать в них две разные версии изменений. А когда в одном commit содержатся чексуммы двух и более других - это **слияние**, то есть данный commit представляет из себя результат объединения файлов и правок внутри них.

Просмотрим все созданные нами объекты

    git cat-file --batch --batch-all-objects

Во многих обычных командах также используется отдельный файл **index** (который ещё может называться stage или cache), в котором перед созданием commit формируется список изменений для создания самого верхнего tree.

Пример добавления записи в index

    git update-index --add --cacheinfo 100644 73977f7f3c8281c5811d17f747535e65f78e899a folder1/folder2/file1.txt

Создать tree по текущему состоянию index

    git write-tree

Также в процессе работы используются **ссылки**, которые заменяют собой чексуммы в командах. Физически это обычные текстовые файлы с чексуммой внутри.

Виды ссылок

- **branch** - последний commit в истории изменений (`refs/heads/`)
- **HEAD** - указывает на branch или commit, на котором по мнению Git мы сейчас находимся
- **tag** - просто удобная ссылка на любой объект (`refs/tags/`)
- tag в виде commit-подобного объекта для добавления подробностей (на этот tag в свою очередь создаётся ссылка из обычного tag)
- **remote** - branch в удалённом хранилище (`refs/remotes/<имя_хранилища>/`)

## Обычная работа с Git

В обычной работе с Git используются высокоуровненые команды, которые делают сразу много низкоуровневых действий.

Допустим у нас есть папка с файлами или новые изменения в них и нам нужно сохранить это в историю Git

    git add -A

Эта команда добавит в index разницу между `HEAD` и рабочей папкой, то есть все новые файлы, изменения, удаления, а все новые данные сохранятся в объектах.

Далее создаём commit для текущего index

    git commit -m 'описание изменений в файлах'

Эта команда также добавит в новый commit чексумму текущего и переместит HEAD на новый commit.

Изменения в файлах можно также добавлять частями, чтобы разнести их по смыслу в разные commit.

- `git add -i` - добавление изменений с помощью командного меню
- `git add -p` - разделное внесение изменений в пределах одного файла
- `git log --graph --oneline --all` - просмотреть всю историю в компактном виде
- `git show a472be2` - показать новые изменения в конкретном commit
- `git diff 2b93ay5 6a94e` - показать разницу двух commit

## checkout

Мы можем возвращать прошлу версию данных из Git в текущую папку

    git checkout 9dd5bt4

Сброс достаёт данные из объектов, но не переключает HEAD

- `git reset eb21e` - загрузить из branch/commit/tree в index
- `git reset --hard eb21er3` - загрузить из branch/commit/tree в index и рабочую папку

Стоит заметить, что `checkout` и `reset` не трогают неизвестные для Git файлы (если они не упоминались ни в одном tree).

- `git clean` - удалить неизвестные для Git файлы в рабочей папке

Если нам не нравятся изменения, сделанные в каком-либо commit, то можно сделать обратный commit

    git revert eb21ew2

## branch

- `git branch` - список всех branch
- `git branch test1` - назначить текущему commit новый branch
- `git branch -m test1 dev1` - переименование
- `git branch -f dev2 2b93af3` - перемещение
- `git switch dev1` - перейти на другой branch и commit
- `git switch -c dev2` - назначить текущему commit новый branch и направить на него HEAD
- `git checkout --orphan b2` - создать независимый branch

Если commit не связан цепочкой commit с каким-либо branch, то он считается недосягаемым и будет удалён при очистке репозитория (и все данные в нём).

- `git fsck --unreachable` - отобразить недосягаемые commit

## merge

*Make us Whole*

Объединение tree из разных branch/commit в один новый. Используется для включения наработок из отдельной ветки в основную. В итоге получается ещё один commit с двумя родителями

    git merge dev1

Если при слиянии обнаружатся разные версии одних и тех же файлов, тогда

- они появятся в `git ls-files --stage` с разными номерами
- `git status` сообщит необходимые действия
- в самих файлах в рабочей папке будут вставлены правки из обеих версий для удобства

После ручного объединения различий потребуется снова добавить их в index и Git разрешит сделать commit.

При слиянии branch, не имеющих общего commit (например, из совершенно разных репозиториев), потребуется опция `--allow-unrelated-histories`. Её добавили, чтобы по умолчанию нельзя было случайно слить вместе несвязанные ветки.

## remote

branch можно передавать в другие репозитории Git.

Для начала добавим удалённый репозиторий

    git remote add example git://example.org:2222/group1/project1.git

Теперь мы можем передать туда branch

    git push branch1 example

Если кто-то также передал изменения, мы можем их получить

    git fetch

Другие команды

- `git clone git://example.org:2222/group1/project1.git` - скачать новый репозиторий и настроить remote
- `git remote -v` - подключенные репозитории
- `git pull` - выполнить `git fetch` и `git merge`

## stash

Если нужно что-то быстренько поковырять в Git, но мешаются файлы в рабочей папке, то необязательно их все переносить куда-то вручную. Можно, конечно, сделать commit, который потом удалить из истории, но есть способ проще.

Быстро сохранить текущие изменения в отдельный commit

    git stash -u

Просмотреть сохранения

    git stash list

Достать последнее сохранение

    git stash apply

## rebase

Перестроение нескольких подряд идущих commit.

В стандартном применении используется для перемещения текущей ветки в конец ветки master, как альтернативное слияние веток

    git rebase master

Переместить от 3b5ae7c до c5930e5 в начало 2a288e6

    git rebase --onto 2a288e6 3b5ae7c c5930e5

Было

```
* c5930e5 (dev) commit7
* cf107c2 commit6
* f1c1faf commit5
* 3b5ae7c (master) commit4
| * 7e12d20 (branch1) commit3
|/  
* 8f67736 commit2
* 2a288e6 (HEAD) commit1
```

Стало

```
* 7bb65d9 (HEAD) commit7
* 95500fc commit6
* ebdac0d commit5
| * c5930e5 (dev) commit7
| * cf107c2 commit6
| * f1c1faf commit5
| * 3b5ae7c (master) commit4
| | * 7e12d20 (branch1) commit3
| |/  
| * 8f67736 commit2
|/  
* 2a288e6 commit1
```

С помощью интерактивного режима можно **полностью переделать историю commit**

    git rebase -i 9e6a86a~

Выведется история от указанного commit до текущего. Слева будет указано применяемое действие, а снизу справка. Например, для объединения нескольких commit меняем `pick` у идущих после него на `squash`. Чтобы наоборот разбить commit на несколько, пишем `edit`. После установки действий сохраняем файл.

На каждый `edit` происходит checkout. Вносим нужные исправления и потом

    git add изменённый_файл1 изменённая_папка2
    git rebase --continue

Либо заносим в index часть изменений (например, через интерактивный add) и делаем

    git commit -m 'часть правок'

Если изменение будет пересекаться с последующим commit, то rebase остановится и предложит сделать merge. Вручную сливаем конфликт и делаем

    git add файл_с_объединением1
    git rebase --continue

Важно заметить, что rebase не меняет текущих данных, а создаёт новые commit, что позволяет всегда отменить процесс rebase, отбросив их

    git rebase --abort

## config

- `git config -l` - текущие настройки
- `git config user.name John Smith` - имя автора commit
- `git config user.email s.john@mail.net` - почта автора commit (может быть пустой строкой)
- `git config core.editor vim` - редактор примечаний при создании commit

## Прочие команды

- `git cherry-pick fc92d5s` - создать новый commit с изменениями, которые произошли в указанном commit по сравнению с его предшественником (можно использовать для перестроения цепочки commit)
- `git ls-tree -r HEAD` - список файлов в tree или commit
- `git fsck` - найти blob/tree, не связанные ни с одним commit
- `git checkout 47c98a3 .` - выгрузить tree в указанную папку


Удаление blob и tree, не связанных ни с одним commit

    git reflog expire --expire=now --all
    git repack -ad
    git prune

## git-filter-repo

Удаление данных из истории

https://docs.github.com/ru/authentication/keeping-your-account-and-data-secure/removing-sensitive-data-from-a-repository#using-git-filter-repo

    pip install --user git-filter-repo
    git-filter-repo --invert-paths --path 'passwords.txt'

