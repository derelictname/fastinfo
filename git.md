# git

```
* 633e6fd (HEAD -> b5) Добавил библиотеку
| * a116155 (b3) Добавил сортировку
| | * 2c627a7 (b4) Рефакторинг
| | | *   d9ea197 (b2) Объединил исправления
| | | |\  
| | |_|/  
| |/| |   
| * | | 2f27fa8 Убрал опечатку
|/ / /  
| | | * cc7239e (master) Объединил код
| | |/| 
| |/|/  
| | * cd55e2e Переписал функцию
| * | 756a56c Очистил код
| | | * 6476854 (b1) Объединил наработки
| |_|/| 
|/| |/  
| |/|   
| * | ec0bcd7 Добавил тесты
* | | 81d030d Добавил документацию
| |/  
|/|   
* | a93c3d2 Исправил ошибку
|/  
* 0d19eb5 Добавил файлы
```

Git используется для отслеживания изменений в файлах, сохранения версий файлов, просмотра истории изменений, возврата к любой версии и объединения результата работы нескольких людей над одними и теми же файлами.

Git состоит из хранилища данных в виде объектов blob, tree и commit, создаваемых в папке objects в подпапках и файлах в соответствии со своей чексуммой, и различных команд для манипуляций над ними.

Для наглядности создадим пустой Git в новой папке и выполним несколько низкоуровневых манипуляций

    git init

Пример создания объекта **blob** с текстом

    echo 'просто текст' | git hash-object -w --stdin

Этот объект используется для хранения содержимого отслеживаемых файлов. Если содержимое менялось, то оно сохранится в новый blob.

Структура папок и список их содержимого строится из объектов **tree**. Один tree хранит имена, права и чексуммы файлов и папок в одной папке.

Выглядит это так

```
tree 7c40534e0fe0bc3e4507ff5c39f3d33c513b6dbb
├── tree myfolder1 83781f91be8e9dcde382a873f2ea4b25240a32bd
│   └── blob sourcefile.c eae0203f03b1864f79f8a4c9e11cc85b503317bb
├── tree myfolder2 29f2577dbbf09f655fd0941927c37f9c04ea4f1e
│   ├── blob program.py b03858d332ea0ac2fe445b257d24454458e54b8d
│   └── blob script.sh e96f119abc426f9b89bfab4774c17e977df6a500
├── blob notes.txt b4e9425c74ae5608b2e25e85f9d8ee9da6565bda
└── blob users.csv 2a1b358981b813acb2b22abd50fb074da249f255
```

Создадим объект tree с одним файлом, который содержит наш текст

    echo -e '100644 blob 73977f7f3c8281c5811d17f747535e65f78e899a\tfile1.txt' | git mktree

В примере выше объект tree с чексуммой `7c40534e...` можно считать основным, так как он содержит всю файловую иерархию.

Чексумма основного tree используется в объекте **commit** для обозначения этого tree в качестве определённой версии всех файлов, которые мы отслеживаем через Git. Также в commit добавляется имя автора, его почта и комментарий.

Пример создания commit

    echo 'добавил файл' | git commit-tree bf6981d12a7bf909b6b717bf944957033a1a258f

Ещё в объекте commit может быть чексумма других commit. Это означает, что его версия файлов является следующей

    echo 'новый текст' | git hash-object -w --stdin
    echo -e '100644 blob 043ede82ab9bf5e5c6cfcdd5735630afa7f05281\tfile1.txt' | git mktree
    echo 'изменил файл' | git commit-tree 14cd11c64a1b90a3b4f3cf1e40bf23778f7a42a8 -p ab1e01f0ac5e75b91d7ffe072b235be195a675a0

Когда на один и тот же commit ссылается множество других - это означает ветвление. Когда в одном commit содержатся чексуммы двух и более других - это означает слияние.

Просмотреть все объекты

    git cat-file --batch --batch-all-objects

Во многих обычных командах используется отдельный файл (**index**, stage, cache), в котором формируется список изменений для формирования основного tree в будущем commit.

Пример добавления записи в index

    git update-index --add --cacheinfo 100644 73977f7f3c8281c5811d17f747535e65f78e899a folder1/folder2/file1.txt

Создать tree по текущему состоянию index

    git write-tree

В большинстве случаев вместо значений чексумм обращение к объектам происходит через названия - ссылки. Физически это обычные текстовые файлы с чексуммой внутри.

Виды ссылок

- **branch** - последний commit в истории изменений (`refs/heads/`)
- **HEAD** - указывает на branch или commit, на котором по мнению Git мы сейчас находимся
- **tag** - просто удобная ссылка на любой объект (`refs/tags/`)
- tag в виде commit-подобного объекта для добавления подробностей (на этот tag в свою очередь создаётся ссылка из обычного tag)
- **remote** - branch в удалённом хранилище (`refs/remotes/<имя_хранилища>/`)

## Начало работы

В обычной работе с Git используются высокоуровненые команды, которые делают сразу несколько действий.

Для отслеживания файлов в рабочей папке создаётся Git в подпапке `.git`, чтобы избежать конфликта

    git init

Следующая команда добавит в index разницу между `HEAD` и рабочей папкой, то есть все новые файлы, изменения, удаления (а также новые данные сохранятся в объектах)

    git add -A

Создаём commit для текущего index

    git commit -m 'сделал то-то и то-то'

Эта команда также добавит в новый commit чексумму текущего и переместит HEAD на новый commit.

Изменения в файлах можно добавлять по частям, чтобы разнести их по разным commit, связав их таким образом по смыслу (что мы и укажем в комментарии к commit).

- `git add -p` - разделное внесение изменений в пределах одного файла
- `git add -i` - добавление с помощью командного меню (рекомендуется)
- `git log --graph --oneline --all` - просмотреть историю commit
- `git show a472be2` - показать изменения данных в commit
- `git diff 2b93ay5 6a94e` - показать разницу данных из разных commit

При необходимости можно загрузить прошлую версию данных

    git checkout 9dd5bt4

Сброс достаёт данные из объектов, но не переключает HEAD

- `git reset eb21e` - загрузить из branch/commit/tree в index
- `git reset --hard eb21er3` - загрузить из branch/commit/tree в index и рабочую папку

`checkout` и `reset` не трогает неизвестные новые файлы в папке.

- `git clean` - удалить неизвестные для Git файлы в рабочей папке

Если нам не нравятся изменения в каком-либо commit, то можно сделать обратный commit

    git revert eb21ew2

## branch

- `git branch` - список всех branch
- `git branch test1` - назначить текущему commit новый branch
- `git branch -m test1 dev1` - переименование
- `git branch -f dev2 2b93af3` - перемещение
- `git switch dev1` - перейти на другой branch и commit
- `git switch -c dev2` - назначить текущему commit новый branch и направить на него HEAD
- `git checkout --orphan b2` - создать независимый branch

Если commit не связан цепочкой commit с каким-либо branch, то он считается недосягаемым и будет удалён при очистке репозитория (и все данные в нём).

- `git fsck --unreachable` - отобразить недосягаемые commit

## merge

*Make us Whole*

Объединение tree из разных branch/commit в один новый. Используется для включения наработок из отдельной ветки в основную. В итоге получается ещё один commit с двумя родителями

    git merge dev1

Если при слиянии обнаружатся разные версии одних и тех же файлов, тогда

- они появятся в `git ls-files --stage` с разными номерами
- `git status` сообщит необходимые действия
- в самих файлах в рабочей папке будут вставлены правки из обеих версий для удобства

После ручного объединения различий потребуется снова добавить их в index и Git разрешит сделать commit.

При слиянии branch, не имеющих общего commit (например, из совершенно разных репозиториев), потребуется опция `--allow-unrelated-histories`. Её добавили, чтобы по умолчанию нельзя было случайно слить вместе несвязанные ветки.

## remote

branch можно передавать в другие репозитории Git.

Для начала добавим удалённый репозиторий

    git remote add example git://example.org:2222/group1/project1.git

Теперь мы можем передать туда branch

    git push branch1 example

Если кто-то также передал изменения, мы можем их получить

    git fetch

Другие команды

- `git clone git://example.org:2222/group1/project1.git` - скачать новый репозиторий и настроить remote
- `git remote -v` - подключенные репозитории
- `git pull` - выполнить `git fetch` и `git merge`

## stash

Большинство операций блокируются при наличии несохранённых изменений в рабочей папке, чтобы не потерять их.

Быстро сохранить текущие изменения в отдельный commit

    git stash -u

Просмотреть сохранения

    git stash list

Загрузить сохранение

    git stash apply stash@{0}

## rebase

Перемещение текущей ветки в конец ветки master

    git rebase master

Переместить от 3b5ae7c до c5930e5 в начало 2a288e6

    git rebase --onto 2a288e6 3b5ae7c c5930e5

Было

```
* c5930e5 (dev) rebased3
* cf107c2 rebased2
* f1c1faf rebased1
* 3b5ae7c (master) mc4
| * 7e12d20 (branch1) commit3
|/  
* 8f67736 commit2
* 2a288e6 (HEAD) commit1
```

Стало

```
* 7bb65d9 (HEAD) rebased3
* 95500fc rebased2
* ebdac0d rebased1
| * c5930e5 (dev) rebased3
| * cf107c2 rebased2
| * f1c1faf rebased1
| * 3b5ae7c (master) mc4
| | * 7e12d20 (branch1) commit3
| |/  
| * 8f67736 commit2
|/  
* 2a288e6 commit1
```

rebase можно использовать для обычной правки старых commit, если выполнить перестроение в то же место

    git rebase -i 9e6a86a~

На исправляемом commit пишем edit вместо pick и сохраняем.

Происходит checkout этого commit. Вносим нужные исправления и потом

    git add -A
    git rebase --continue

Выполнится merge изменения со всеми последующими commit. В случае конфликта исправляем их и снова

    git add -A
    git rebase --continue

При rebase текущие commit не трогаются, а создаются новые, поэтому всегда можно процесс отменить

    git rebase --abort


## config

- `git config -l` - текущие настройки
- `git config user.name John Smith` - имя автора commit
- `git config user.email s.john@mail.net` - почта автора commit (может быть пустой строкой)
- `git config core.editor vim` - редактор примечаний при создании commit

## Прочие команды

- `git cherry-pick fc92d5s` - создать новый commit с изменениями, которые произошли в указанном commit по сравнению с идущим перед ним (можно использовать для перестроения цепочки commit)
- `git ls-tree -r HEAD` - список файлов в tree или commit
- `git fsck` - найти blob/tree, не связанные ни с одним commit
- `git checkout 47c98a3 .` - выгрузить tree в указанную папку


Удаление blob и tree, не связанных ни с одним commit

    git reflog expire --expire=now --all
    git repack -ad
    git prune



